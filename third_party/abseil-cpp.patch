diff --git a/absl/functional/BUILD.bazel b/absl/functional/BUILD.bazel
new file mode 100644
index 0000000..432546c
--- /dev/null
+++ b/absl/functional/BUILD.bazel
@@ -0,0 +1,93 @@
+#
+# Copyright 2019 The Abseil Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+load("@rules_cc//cc:defs.bzl", "cc_library", "cc_test")
+load(
+    "//absl:copts/configure_copts.bzl",
+    "ABSL_DEFAULT_COPTS",
+    "ABSL_DEFAULT_LINKOPTS",
+    "ABSL_TEST_COPTS",
+)
+
+package(default_visibility = ["//visibility:public"])
+
+licenses(["notice"])  # Apache 2.0
+
+cc_library(
+    name = "bind_front",
+    srcs = ["internal/front_binder.h"],
+    hdrs = ["bind_front.h"],
+    copts = ABSL_DEFAULT_COPTS,
+    linkopts = ABSL_DEFAULT_LINKOPTS,
+    deps = [
+        "//absl/base:base_internal",
+        "//absl/container:compressed_tuple",
+        "//absl/meta:type_traits",
+        "//absl/utility",
+    ],
+)
+
+cc_test(
+    name = "bind_front_test",
+    srcs = ["bind_front_test.cc"],
+    copts = ABSL_TEST_COPTS,
+    linkopts = ABSL_DEFAULT_LINKOPTS,
+    deps = [
+        ":bind_front",
+        "//absl/memory",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+cc_library(
+    name = "function_ref",
+    srcs = ["internal/function_ref.h"],
+    hdrs = ["function_ref.h"],
+    copts = ABSL_DEFAULT_COPTS,
+    linkopts = ABSL_DEFAULT_LINKOPTS,
+    deps = [
+        "//absl/base:base_internal",
+        "//absl/meta:type_traits",
+    ],
+)
+
+cc_test(
+    name = "function_ref_test",
+    size = "small",
+    srcs = ["function_ref_test.cc"],
+    copts = ABSL_TEST_COPTS,
+    deps = [
+        ":function_ref",
+        "//absl/container:test_instance_tracker",
+        "//absl/memory",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
+cc_test(
+    name = "function_ref_benchmark",
+    srcs = [
+        "function_ref_benchmark.cc",
+    ],
+    copts = ABSL_TEST_COPTS,
+    tags = ["benchmark"],
+    visibility = ["//visibility:private"],
+    deps = [
+        ":function_ref",
+        "//absl/base:core_headers",
+        "@com_github_google_benchmark//:benchmark_main",
+    ],
+)
diff --git a/absl/functional/bind_front.h b/absl/functional/bind_front.h
new file mode 100644
index 0000000..687090a
--- /dev/null
+++ b/absl/functional/bind_front.h
@@ -0,0 +1,166 @@
+// Copyright 2018 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// -----------------------------------------------------------------------------
+// File: bind_front.h
+// -----------------------------------------------------------------------------
+//
+// `absl::bind_front()` returns a functor by binding a number of arguments to
+// the front of a provided (usually more generic) functor. Unlike `std::bind`,
+// it does not require the use of argument placeholders. The simpler syntax of
+// `absl::bind_front()` allows you to avoid known misuses with `std::bind()`.
+//
+// `absl::bind_front()` is meant as a drop-in replacement for C++20's upcoming
+// `std::bind_front()`, which similarly resolves these issues with
+// `std::bind()`. Both `bind_front()` alternatives, unlike `std::bind()`, allow
+// partial function application. (See
+// https://en.wikipedia.org/wiki/Partial_application).
+
+#ifndef ABSL_FUNCTIONAL_BIND_FRONT_H_
+#define ABSL_FUNCTIONAL_BIND_FRONT_H_
+
+#include "absl/functional/internal/front_binder.h"
+#include "absl/utility/utility.h"
+
+namespace absl {
+inline namespace lts_2019_08_08 {
+
+// bind_front()
+//
+// Binds the first N arguments of an invocable object and stores them by value,
+// except types of `std::reference_wrapper` which are 'unwound' and stored by
+// reference.
+//
+// Like `std::bind()`, `absl::bind_front()` is implicitly convertible to
+// `std::function`.  In particular, it may be used as a simpler replacement for
+// `std::bind()` in most cases, as it does not require  placeholders to be
+// specified. More importantly, it provides more reliable correctness guarantees
+// than `std::bind()`; while `std::bind()` will silently ignore passing more
+// parameters than expected, for example, `absl::bind_front()` will report such
+// mis-uses as errors.
+//
+// absl::bind_front(a...) can be seen as storing the results of
+// std::make_tuple(a...).
+//
+// Example: Binding a free function.
+//
+//   int Minus(int a, int b) { return a - b; }
+//
+//   assert(absl::bind_front(Minus)(3, 2) == 3 - 2);
+//   assert(absl::bind_front(Minus, 3)(2) == 3 - 2);
+//   assert(absl::bind_front(Minus, 3, 2)() == 3 - 2);
+//
+// Example: Binding a member function.
+//
+//   struct Math {
+//     int Double(int a) const { return 2 * a; }
+//   };
+//
+//   Math math;
+//
+//   assert(absl::bind_front(&Math::Double)(&math, 3) == 2 * 3);
+//   // Stores a pointer to math inside the functor.
+//   assert(absl::bind_front(&Math::Double, &math)(3) == 2 * 3);
+//   // Stores a copy of math inside the functor.
+//   assert(absl::bind_front(&Math::Double, math)(3) == 2 * 3);
+//   // Stores std::unique_ptr<Math> inside the functor.
+//   assert(absl::bind_front(&Math::Double,
+//                           std::unique_ptr<Math>(new Math))(3) == 2 * 3);
+//
+// Example: Using `absl::bind_front()`, instead of `std::bind()`, with
+//          `std::function`.
+//
+//   class FileReader {
+//    public:
+//     void ReadFileAsync(const std::string& filename, std::string* content,
+//                        const std::function<void()>& done) {
+//       // Calls Executor::Schedule(std::function<void()>).
+//       Executor::DefaultExecutor()->Schedule(
+//           absl::bind_front(&FileReader::BlockingRead, this,
+//                            filename, content, done));
+//     }
+//
+//    private:
+//     void BlockingRead(const std::string& filename, std::string* content,
+//                       const std::function<void()>& done) {
+//       CHECK_OK(file::GetContents(filename, content, {}));
+//       done();
+//     }
+//   };
+//
+// `absl::bind_front()` stores bound arguments explicitly using the type passed
+// rather than implicitly based on the type accepted by its functor.
+//
+// Example: Binding arguments explicitly.
+//
+//   void LogStringView(absl::string_view sv) {
+//     LOG(INFO) << sv;
+//   }
+//
+//   Executor* e = Executor::DefaultExecutor();
+//   std::string s = "hello";
+//   absl::string_view sv = s;
+//
+//   // absl::bind_front(LogStringView, arg) makes a copy of arg and stores it.
+//   e->Schedule(absl::bind_front(LogStringView, sv)); // ERROR: dangling
+//                                                     // string_view.
+//
+//   e->Schedule(absl::bind_front(LogStringView, s));  // OK: stores a copy of
+//                                                     // s.
+//
+// To store some of the arguments passed to `absl::bind_front()` by reference,
+//  use std::ref()` and `std::cref()`.
+//
+// Example: Storing some of the bound arguments by reference.
+//
+//   class Service {
+//    public:
+//     void Serve(const Request& req, std::function<void()>* done) {
+//       // The request protocol buffer won't be deleted until done is called.
+//       // It's safe to store a reference to it inside the functor.
+//       Executor::DefaultExecutor()->Schedule(
+//           absl::bind_front(&Service::BlockingServe, this, std::cref(req),
+//           done));
+//     }
+//
+//    private:
+//     void BlockingServe(const Request& req, std::function<void()>* done);
+//   };
+//
+// Example: Storing bound arguments by reference.
+//
+//   void Print(const string& a, const string& b) { LOG(INFO) << a << b; }
+//
+//   std::string hi = "Hello, ";
+//   std::vector<std::string> names = {"Chuk", "Gek"};
+//   // Doesn't copy hi.
+//   for_each(names.begin(), names.end(),
+//            absl::bind_front(Print, std::ref(hi)));
+//
+//   // DO NOT DO THIS: the functor may outlive "hi", resulting in
+//   // dangling references.
+//   foo->DoInFuture(absl::bind_front(Print, std::ref(hi), "Guest"));  // BAD!
+//   auto f = absl::bind_front(Print, std::ref(hi), "Guest"); // BAD!
+template <class F, class... BoundArgs>
+constexpr functional_internal::bind_front_t<F, BoundArgs...> bind_front(
+    F&& func, BoundArgs&&... args) {
+  return functional_internal::bind_front_t<F, BoundArgs...>(
+      absl::in_place, absl::forward<F>(func),
+      absl::forward<BoundArgs>(args)...);
+}
+
+}  // inline namespace lts_2019_08_08
+}  // namespace absl
+
+#endif  // ABSL_FUNCTIONAL_BIND_FRONT_H_
diff --git a/absl/functional/bind_front_test.cc b/absl/functional/bind_front_test.cc
new file mode 100644
index 0000000..4801a81
--- /dev/null
+++ b/absl/functional/bind_front_test.cc
@@ -0,0 +1,231 @@
+// Copyright 2018 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "absl/functional/bind_front.h"
+
+#include <stddef.h>
+
+#include <functional>
+#include <memory>
+#include <string>
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "absl/memory/memory.h"
+
+namespace {
+
+char CharAt(const char* s, size_t index) { return s[index]; }
+
+TEST(BindTest, Basics) {
+  EXPECT_EQ('C', absl::bind_front(CharAt)("ABC", 2));
+  EXPECT_EQ('C', absl::bind_front(CharAt, "ABC")(2));
+  EXPECT_EQ('C', absl::bind_front(CharAt, "ABC", 2)());
+}
+
+TEST(BindTest, Lambda) {
+  auto lambda = [](int x, int y, int z) { return x + y + z; };
+  EXPECT_EQ(6, absl::bind_front(lambda)(1, 2, 3));
+  EXPECT_EQ(6, absl::bind_front(lambda, 1)(2, 3));
+  EXPECT_EQ(6, absl::bind_front(lambda, 1, 2)(3));
+  EXPECT_EQ(6, absl::bind_front(lambda, 1, 2, 3)());
+}
+
+struct Functor {
+  std::string operator()() & { return "&"; }
+  std::string operator()() const& { return "const&"; }
+  std::string operator()() && { return "&&"; }
+  std::string operator()() const&& { return "const&&"; }
+};
+
+TEST(BindTest, PerfectForwardingOfBoundArgs) {
+  auto f = absl::bind_front(Functor());
+  const auto& cf = f;
+  EXPECT_EQ("&", f());
+  EXPECT_EQ("const&", cf());
+  EXPECT_EQ("&&", std::move(f)());
+  EXPECT_EQ("const&&", std::move(cf)());
+}
+
+struct ArgDescribe {
+  std::string operator()(int&) const { return "&"; }             // NOLINT
+  std::string operator()(const int&) const { return "const&"; }  // NOLINT
+  std::string operator()(int&&) const { return "&&"; }
+  std::string operator()(const int&&) const { return "const&&"; }
+};
+
+TEST(BindTest, PerfectForwardingOfFreeArgs) {
+  ArgDescribe f;
+  int i;
+  EXPECT_EQ("&", absl::bind_front(f)(static_cast<int&>(i)));
+  EXPECT_EQ("const&", absl::bind_front(f)(static_cast<const int&>(i)));
+  EXPECT_EQ("&&", absl::bind_front(f)(static_cast<int&&>(i)));
+  EXPECT_EQ("const&&", absl::bind_front(f)(static_cast<const int&&>(i)));
+}
+
+struct NonCopyableFunctor {
+  NonCopyableFunctor() = default;
+  NonCopyableFunctor(const NonCopyableFunctor&) = delete;
+  NonCopyableFunctor& operator=(const NonCopyableFunctor&) = delete;
+  const NonCopyableFunctor* operator()() const { return this; }
+};
+
+TEST(BindTest, RefToFunctor) {
+  // It won't copy/move the functor and use the original object.
+  NonCopyableFunctor ncf;
+  auto bound_ncf = absl::bind_front(std::ref(ncf));
+  auto bound_ncf_copy = bound_ncf;
+  EXPECT_EQ(&ncf, bound_ncf_copy());
+}
+
+struct Struct {
+  std::string value;
+};
+
+TEST(BindTest, StoreByCopy) {
+  Struct s = {"hello"};
+  auto f = absl::bind_front(&Struct::value, s);
+  auto g = f;
+  EXPECT_EQ("hello", f());
+  EXPECT_EQ("hello", g());
+  EXPECT_NE(&s.value, &f());
+  EXPECT_NE(&s.value, &g());
+  EXPECT_NE(&g(), &f());
+}
+
+struct NonCopyable {
+  explicit NonCopyable(const std::string& s) : value(s) {}
+  NonCopyable(const NonCopyable&) = delete;
+  NonCopyable& operator=(const NonCopyable&) = delete;
+
+  std::string value;
+};
+
+const std::string& GetNonCopyableValue(const NonCopyable& n) { return n.value; }
+
+TEST(BindTest, StoreByRef) {
+  NonCopyable s("hello");
+  auto f = absl::bind_front(&GetNonCopyableValue, std::ref(s));
+  EXPECT_EQ("hello", f());
+  EXPECT_EQ(&s.value, &f());
+  auto g = std::move(f);  // NOLINT
+  EXPECT_EQ("hello", g());
+  EXPECT_EQ(&s.value, &g());
+  s.value = "goodbye";
+  EXPECT_EQ("goodbye", g());
+}
+
+TEST(BindTest, StoreByCRef) {
+  NonCopyable s("hello");
+  auto f = absl::bind_front(&GetNonCopyableValue, std::cref(s));
+  EXPECT_EQ("hello", f());
+  EXPECT_EQ(&s.value, &f());
+  auto g = std::move(f);  // NOLINT
+  EXPECT_EQ("hello", g());
+  EXPECT_EQ(&s.value, &g());
+  s.value = "goodbye";
+  EXPECT_EQ("goodbye", g());
+}
+
+const std::string& GetNonCopyableValueByWrapper(
+    std::reference_wrapper<NonCopyable> n) {
+  return n.get().value;
+}
+
+TEST(BindTest, StoreByRefInvokeByWrapper) {
+  NonCopyable s("hello");
+  auto f = absl::bind_front(GetNonCopyableValueByWrapper, std::ref(s));
+  EXPECT_EQ("hello", f());
+  EXPECT_EQ(&s.value, &f());
+  auto g = std::move(f);
+  EXPECT_EQ("hello", g());
+  EXPECT_EQ(&s.value, &g());
+  s.value = "goodbye";
+  EXPECT_EQ("goodbye", g());
+}
+
+TEST(BindTest, StoreByPointer) {
+  NonCopyable s("hello");
+  auto f = absl::bind_front(&NonCopyable::value, &s);
+  EXPECT_EQ("hello", f());
+  EXPECT_EQ(&s.value, &f());
+  auto g = std::move(f);
+  EXPECT_EQ("hello", g());
+  EXPECT_EQ(&s.value, &g());
+}
+
+int Sink(std::unique_ptr<int> p) {
+  return *p;
+}
+
+std::unique_ptr<int> Factory(int n) { return absl::make_unique<int>(n); }
+
+TEST(BindTest, NonCopyableArg) {
+  EXPECT_EQ(42, absl::bind_front(Sink)(absl::make_unique<int>(42)));
+  EXPECT_EQ(42, absl::bind_front(Sink, absl::make_unique<int>(42))());
+}
+
+TEST(BindTest, NonCopyableResult) {
+  EXPECT_THAT(absl::bind_front(Factory)(42), ::testing::Pointee(42));
+  EXPECT_THAT(absl::bind_front(Factory, 42)(), ::testing::Pointee(42));
+}
+
+// is_copy_constructible<FalseCopyable<unique_ptr<T>> is true but an attempt to
+// instantiate the copy constructor leads to a compile error. This is similar
+// to how standard containers behave.
+template <class T>
+struct FalseCopyable {
+  FalseCopyable() {}
+  FalseCopyable(const FalseCopyable& other) : m(other.m) {}
+  FalseCopyable(FalseCopyable&& other) : m(std::move(other.m)) {}
+  T m;
+};
+
+int GetMember(FalseCopyable<std::unique_ptr<int>> x) { return *x.m; }
+
+TEST(BindTest, WrappedMoveOnly) {
+  FalseCopyable<std::unique_ptr<int>> x;
+  x.m = absl::make_unique<int>(42);
+  auto f = absl::bind_front(&GetMember, std::move(x));
+  EXPECT_EQ(42, std::move(f)());
+}
+
+int Plus(int a, int b) { return a + b; }
+
+TEST(BindTest, ConstExpr) {
+  constexpr auto f = absl::bind_front(CharAt);
+  EXPECT_EQ(f("ABC", 1), 'B');
+  static constexpr int five = 5;
+  constexpr auto plus5 = absl::bind_front(Plus, five);
+  EXPECT_EQ(plus5(1), 6);
+
+  // There seems to be a bug in MSVC dealing constexpr construction of
+  // char[]. Notice 'plus5' above; 'int' works just fine.
+#if !(defined(_MSC_VER) && _MSC_VER < 1910)
+  static constexpr char data[] = "DEF";
+  constexpr auto g = absl::bind_front(CharAt, data);
+  EXPECT_EQ(g(1), 'E');
+#endif
+}
+
+struct ManglingCall {
+  int operator()(int, double, std::string) const { return 0; }
+};
+
+TEST(BindTest, Mangling) {
+  // We just want to generate a particular instantiation to see its mangling.
+  absl::bind_front(ManglingCall{}, 1, 3.3)("A");
+}
+
+}  // namespace
diff --git a/absl/functional/function_ref.h b/absl/functional/function_ref.h
new file mode 100644
index 0000000..751736e
--- /dev/null
+++ b/absl/functional/function_ref.h
@@ -0,0 +1,139 @@
+// Copyright 2019 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// -----------------------------------------------------------------------------
+// File: function_ref.h
+// -----------------------------------------------------------------------------
+//
+// This header file defines the `absl::FunctionRef` type for holding a
+// non-owning reference to an object of any invocable type. This function
+// reference is typically most useful as a type-erased argument type for
+// accepting function types that neither take ownership nor copy the type; using
+// the reference type in this case avoids a copy and an allocation. Best
+// practices of other non-owning reference-like objects (such as
+// `absl::string_view`) apply here.
+//
+//  An `absl::FunctionRef` is similar in usage to a `std::function` but has the
+//  following differences:
+//
+//  * It doesn't own the underlying object.
+//  * It doesn't have a null or empty state.
+//  * It never performs deep copies or allocations.
+//  * It's much faster and cheaper to construct.
+//  * It's trivially copyable and destructable.
+//
+// Generally, `absl::FunctionRef` should not be used as a return value, data
+// member, or to initialize a `std::function`. Such usages will often lead to
+// problematic lifetime issues. Once you convert something to an
+// `absl::FunctionRef` you cannot make a deep copy later.
+//
+// This class is suitable for use wherever a "const std::function<>&"
+// would be used without making a copy. ForEach functions and other versions of
+// the visitor pattern are a good example of when this class should be used.
+//
+// This class is trivial to copy and should be passed by value.
+#ifndef ABSL_FUNCTIONAL_FUNCTION_REF_H_
+#define ABSL_FUNCTIONAL_FUNCTION_REF_H_
+
+#include <cassert>
+#include <functional>
+#include <type_traits>
+
+#include "absl/functional/internal/function_ref.h"
+#include "absl/meta/type_traits.h"
+
+namespace absl {
+inline namespace lts_2019_08_08 {
+
+// FunctionRef
+//
+// Dummy class declaration to allow the partial specialization based on function
+// types below.
+template <typename T>
+class FunctionRef;
+
+// FunctionRef
+//
+// An `absl::FunctionRef` is a lightweight wrapper to any invokable object with
+// a compatible signature. Generally, an `absl::FunctionRef` should only be used
+// as an argument type and should be preferred as an argument over a const
+// reference to a `std::function`.
+//
+// Example:
+//
+//   // The following function takes a function callback by const reference
+//   bool Visitor(const std::function<void(my_proto&,
+//                                         absl::string_view)>& callback);
+//
+//   // Assuming that the function is not stored or otherwise copied, it can be
+//   // replaced by an `absl::FunctionRef`:
+//   bool Visitor(absl::FunctionRef<void(my_proto&, absl::string_view)>
+//                  callback);
+//
+// Note: the assignment operator within an `absl::FunctionRef` is intentionally
+// deleted to prevent misuse; because the `absl::FunctionRef` does not own the
+// underlying type, assignment likely indicates misuse.
+template <typename R, typename... Args>
+class FunctionRef<R(Args...)> {
+ private:
+  // Used to disable constructors for objects that are not compatible with the
+  // signature of this FunctionRef.
+  template <typename F,
+            typename FR = absl::base_internal::InvokeT<F, Args&&...>>
+  using EnableIfCompatible =
+      typename std::enable_if<std::is_void<R>::value ||
+                              std::is_convertible<FR, R>::value>::type;
+
+ public:
+  // Constructs a FunctionRef from any invokable type.
+  template <typename F, typename = EnableIfCompatible<const F&>>
+  FunctionRef(const F& f)  // NOLINT(runtime/explicit)
+      : invoker_(&absl::functional_internal::InvokeObject<F, R, Args...>) {
+    absl::functional_internal::AssertNonNull(f);
+    ptr_.obj = &f;
+  }
+
+  // Overload for function pointers. This eliminates a level of indirection that
+  // would happen if the above overload was used (it lets us store the pointer
+  // instead of a pointer to a pointer).
+  //
+  // This overload is also used for references to functions, since references to
+  // functions can decay to function pointers implicitly.
+  template <
+      typename F, typename = EnableIfCompatible<F*>,
+      absl::functional_internal::EnableIf<absl::is_function<F>::value> = 0>
+  FunctionRef(F* f)  // NOLINT(runtime/explicit)
+      : invoker_(&absl::functional_internal::InvokeFunction<F*, R, Args...>) {
+    assert(f != nullptr);
+    ptr_.fun = reinterpret_cast<decltype(ptr_.fun)>(f);
+  }
+
+  // To help prevent subtle lifetime bugs, FunctionRef is not assignable.
+  // Typically, it should only be used as an argument type.
+  FunctionRef& operator=(const FunctionRef& rhs) = delete;
+
+  // Call the underlying object.
+  R operator()(Args... args) const {
+    return invoker_(ptr_, std::forward<Args>(args)...);
+  }
+
+ private:
+  absl::functional_internal::VoidPtr ptr_;
+  absl::functional_internal::Invoker<R, Args...> invoker_;
+};
+
+}  // inline namespace lts_2019_08_08
+}  // namespace absl
+
+#endif  // ABSL_FUNCTIONAL_FUNCTION_REF_H_
diff --git a/absl/functional/function_ref_benchmark.cc b/absl/functional/function_ref_benchmark.cc
new file mode 100644
index 0000000..d943b13
--- /dev/null
+++ b/absl/functional/function_ref_benchmark.cc
@@ -0,0 +1,142 @@
+// Copyright 2019 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "absl/functional/function_ref.h"
+
+#include <memory>
+
+#include "benchmark/benchmark.h"
+#include "absl/base/attributes.h"
+
+namespace absl {
+inline namespace lts_2019_08_08 {
+namespace {
+
+int dummy = 0;
+
+void FreeFunction() { benchmark::DoNotOptimize(dummy); }
+
+struct TrivialFunctor {
+  void operator()() const { benchmark::DoNotOptimize(dummy); }
+};
+
+struct LargeFunctor {
+  void operator()() const { benchmark::DoNotOptimize(this); }
+  std::string a, b, c;
+};
+
+template <typename Function, typename... Args>
+void ABSL_ATTRIBUTE_NOINLINE CallFunction(Function f, Args&&... args) {
+  f(std::forward<Args>(args)...);
+}
+
+template <typename Function, typename Callable, typename... Args>
+void ConstructAndCallFunctionBenchmark(benchmark::State& state,
+                                       const Callable& c, Args&&... args) {
+  for (auto _ : state) {
+    CallFunction<Function>(c, std::forward<Args>(args)...);
+  }
+}
+
+void BM_TrivialStdFunction(benchmark::State& state) {
+  ConstructAndCallFunctionBenchmark<std::function<void()>>(state,
+                                                           TrivialFunctor{});
+}
+BENCHMARK(BM_TrivialStdFunction);
+
+void BM_TrivialFunctionRef(benchmark::State& state) {
+  ConstructAndCallFunctionBenchmark<FunctionRef<void()>>(state,
+                                                         TrivialFunctor{});
+}
+BENCHMARK(BM_TrivialFunctionRef);
+
+void BM_LargeStdFunction(benchmark::State& state) {
+  ConstructAndCallFunctionBenchmark<std::function<void()>>(state,
+                                                           LargeFunctor{});
+}
+BENCHMARK(BM_LargeStdFunction);
+
+void BM_LargeFunctionRef(benchmark::State& state) {
+  ConstructAndCallFunctionBenchmark<FunctionRef<void()>>(state, LargeFunctor{});
+}
+BENCHMARK(BM_LargeFunctionRef);
+
+void BM_FunPtrStdFunction(benchmark::State& state) {
+  ConstructAndCallFunctionBenchmark<std::function<void()>>(state, FreeFunction);
+}
+BENCHMARK(BM_FunPtrStdFunction);
+
+void BM_FunPtrFunctionRef(benchmark::State& state) {
+  ConstructAndCallFunctionBenchmark<FunctionRef<void()>>(state, FreeFunction);
+}
+BENCHMARK(BM_FunPtrFunctionRef);
+
+// Doesn't include construction or copy overhead in the loop.
+template <typename Function, typename Callable, typename... Args>
+void CallFunctionBenchmark(benchmark::State& state, const Callable& c,
+                           Args... args) {
+  Function f = c;
+  for (auto _ : state) {
+    benchmark::DoNotOptimize(&f);
+    f(args...);
+  }
+}
+
+struct FunctorWithTrivialArgs {
+  void operator()(int a, int b, int c) const {
+    benchmark::DoNotOptimize(a);
+    benchmark::DoNotOptimize(b);
+    benchmark::DoNotOptimize(c);
+  }
+};
+
+void BM_TrivialArgsStdFunction(benchmark::State& state) {
+  CallFunctionBenchmark<std::function<void(int, int, int)>>(
+      state, FunctorWithTrivialArgs{}, 1, 2, 3);
+}
+BENCHMARK(BM_TrivialArgsStdFunction);
+
+void BM_TrivialArgsFunctionRef(benchmark::State& state) {
+  CallFunctionBenchmark<FunctionRef<void(int, int, int)>>(
+      state, FunctorWithTrivialArgs{}, 1, 2, 3);
+}
+BENCHMARK(BM_TrivialArgsFunctionRef);
+
+struct FunctorWithNonTrivialArgs {
+  void operator()(std::string a, std::string b, std::string c) const {
+    benchmark::DoNotOptimize(&a);
+    benchmark::DoNotOptimize(&b);
+    benchmark::DoNotOptimize(&c);
+  }
+};
+
+void BM_NonTrivialArgsStdFunction(benchmark::State& state) {
+  std::string a, b, c;
+  CallFunctionBenchmark<
+      std::function<void(std::string, std::string, std::string)>>(
+      state, FunctorWithNonTrivialArgs{}, a, b, c);
+}
+BENCHMARK(BM_NonTrivialArgsStdFunction);
+
+void BM_NonTrivialArgsFunctionRef(benchmark::State& state) {
+  std::string a, b, c;
+  CallFunctionBenchmark<
+      FunctionRef<void(std::string, std::string, std::string)>>(
+      state, FunctorWithNonTrivialArgs{}, a, b, c);
+}
+BENCHMARK(BM_NonTrivialArgsFunctionRef);
+
+}  // namespace
+}  // inline namespace lts_2019_08_08
+}  // namespace absl
diff --git a/absl/functional/function_ref_test.cc b/absl/functional/function_ref_test.cc
new file mode 100644
index 0000000..6825ee4
--- /dev/null
+++ b/absl/functional/function_ref_test.cc
@@ -0,0 +1,257 @@
+// Copyright 2019 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "absl/functional/function_ref.h"
+
+#include <memory>
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "absl/container/internal/test_instance_tracker.h"
+#include "absl/memory/memory.h"
+
+namespace absl {
+inline namespace lts_2019_08_08 {
+namespace {
+
+void RunFun(FunctionRef<void()> f) { f(); }
+
+TEST(FunctionRefTest, Lambda) {
+  bool ran = false;
+  RunFun([&] { ran = true; });
+  EXPECT_TRUE(ran);
+}
+
+int Function() { return 1337; }
+
+TEST(FunctionRefTest, Function1) {
+  FunctionRef<int()> ref(&Function);
+  EXPECT_EQ(1337, ref());
+}
+
+TEST(FunctionRefTest, Function2) {
+  FunctionRef<int()> ref(Function);
+  EXPECT_EQ(1337, ref());
+}
+
+int NoExceptFunction() noexcept { return 1337; }
+
+// TODO(jdennett): Add a test for noexcept member functions.
+TEST(FunctionRefTest, NoExceptFunction) {
+  FunctionRef<int()> ref(NoExceptFunction);
+  EXPECT_EQ(1337, ref());
+}
+
+TEST(FunctionRefTest, ForwardsArgs) {
+  auto l = [](std::unique_ptr<int> i) { return *i; };
+  FunctionRef<int(std::unique_ptr<int>)> ref(l);
+  EXPECT_EQ(42, ref(absl::make_unique<int>(42)));
+}
+
+TEST(FunctionRef, ReturnMoveOnly) {
+  auto l = [] { return absl::make_unique<int>(29); };
+  FunctionRef<std::unique_ptr<int>()> ref(l);
+  EXPECT_EQ(29, *ref());
+}
+
+TEST(FunctionRef, ManyArgs) {
+  auto l = [](int a, int b, int c) { return a + b + c; };
+  FunctionRef<int(int, int, int)> ref(l);
+  EXPECT_EQ(6, ref(1, 2, 3));
+}
+
+TEST(FunctionRef, VoidResultFromNonVoidFunctor) {
+  bool ran = false;
+  auto l = [&]() -> int {
+    ran = true;
+    return 2;
+  };
+  FunctionRef<void()> ref(l);
+  ref();
+  EXPECT_TRUE(ran);
+}
+
+TEST(FunctionRef, CastFromDerived) {
+  struct Base {};
+  struct Derived : public Base {};
+
+  Derived d;
+  auto l1 = [&](Base* b) { EXPECT_EQ(&d, b); };
+  FunctionRef<void(Derived*)> ref1(l1);
+  ref1(&d);
+
+  auto l2 = [&]() -> Derived* { return &d; };
+  FunctionRef<Base*()> ref2(l2);
+  EXPECT_EQ(&d, ref2());
+}
+
+TEST(FunctionRef, VoidResultFromNonVoidFuncton) {
+  FunctionRef<void()> ref(Function);
+  ref();
+}
+
+TEST(FunctionRef, MemberPtr) {
+  struct S {
+    int i;
+  };
+
+  S s{1100111};
+  auto mem_ptr = &S::i;
+  FunctionRef<int(const S& s)> ref(mem_ptr);
+  EXPECT_EQ(1100111, ref(s));
+}
+
+TEST(FunctionRef, MemberFun) {
+  struct S {
+    int i;
+    int get_i() const { return i; }
+  };
+
+  S s{22};
+  auto mem_fun_ptr = &S::get_i;
+  FunctionRef<int(const S& s)> ref(mem_fun_ptr);
+  EXPECT_EQ(22, ref(s));
+}
+
+TEST(FunctionRef, MemberFunRefqualified) {
+  struct S {
+    int i;
+    int get_i() && { return i; }
+  };
+  auto mem_fun_ptr = &S::get_i;
+  S s{22};
+  FunctionRef<int(S && s)> ref(mem_fun_ptr);
+  EXPECT_EQ(22, ref(std::move(s)));
+}
+
+#if !defined(_WIN32) && defined(GTEST_HAS_DEATH_TEST)
+
+TEST(FunctionRef, MemberFunRefqualifiedNull) {
+  struct S {
+    int i;
+    int get_i() && { return i; }
+  };
+  auto mem_fun_ptr = &S::get_i;
+  mem_fun_ptr = nullptr;
+  EXPECT_DEBUG_DEATH({ FunctionRef<int(S && s)> ref(mem_fun_ptr); }, "");
+}
+
+TEST(FunctionRef, NullMemberPtrAssertFails) {
+  struct S {
+    int i;
+  };
+  using MemberPtr = int S::*;
+  MemberPtr mem_ptr = nullptr;
+  EXPECT_DEBUG_DEATH({ FunctionRef<int(const S& s)> ref(mem_ptr); }, "");
+}
+
+#endif  // GTEST_HAS_DEATH_TEST
+
+TEST(FunctionRef, CopiesAndMovesPerPassByValue) {
+  absl::test_internal::InstanceTracker tracker;
+  absl::test_internal::CopyableMovableInstance instance(0);
+  auto l = [](absl::test_internal::CopyableMovableInstance) {};
+  FunctionRef<void(absl::test_internal::CopyableMovableInstance)> ref(l);
+  ref(instance);
+  EXPECT_EQ(tracker.copies(), 1);
+  EXPECT_EQ(tracker.moves(), 1);
+}
+
+TEST(FunctionRef, CopiesAndMovesPerPassByRef) {
+  absl::test_internal::InstanceTracker tracker;
+  absl::test_internal::CopyableMovableInstance instance(0);
+  auto l = [](const absl::test_internal::CopyableMovableInstance&) {};
+  FunctionRef<void(const absl::test_internal::CopyableMovableInstance&)> ref(l);
+  ref(instance);
+  EXPECT_EQ(tracker.copies(), 0);
+  EXPECT_EQ(tracker.moves(), 0);
+}
+
+TEST(FunctionRef, CopiesAndMovesPerPassByValueCallByMove) {
+  absl::test_internal::InstanceTracker tracker;
+  absl::test_internal::CopyableMovableInstance instance(0);
+  auto l = [](absl::test_internal::CopyableMovableInstance) {};
+  FunctionRef<void(absl::test_internal::CopyableMovableInstance)> ref(l);
+  ref(std::move(instance));
+  EXPECT_EQ(tracker.copies(), 0);
+  EXPECT_EQ(tracker.moves(), 2);
+}
+
+TEST(FunctionRef, CopiesAndMovesPerPassByValueToRef) {
+  absl::test_internal::InstanceTracker tracker;
+  absl::test_internal::CopyableMovableInstance instance(0);
+  auto l = [](const absl::test_internal::CopyableMovableInstance&) {};
+  FunctionRef<void(absl::test_internal::CopyableMovableInstance)> ref(l);
+  ref(std::move(instance));
+  EXPECT_EQ(tracker.copies(), 0);
+  EXPECT_EQ(tracker.moves(), 1);
+}
+
+TEST(FunctionRef, PassByValueTypes) {
+  using absl::functional_internal::Invoker;
+  using absl::functional_internal::VoidPtr;
+  using absl::test_internal::CopyableMovableInstance;
+  struct Trivial {
+    void* p[2];
+  };
+  struct LargeTrivial {
+    void* p[3];
+  };
+
+  static_assert(std::is_same<Invoker<void, int>, void (*)(VoidPtr, int)>::value,
+                "Scalar types should be passed by value");
+  static_assert(
+      std::is_same<Invoker<void, Trivial>, void (*)(VoidPtr, Trivial)>::value,
+      "Small trivial types should be passed by value");
+  static_assert(std::is_same<Invoker<void, LargeTrivial>,
+                             void (*)(VoidPtr, LargeTrivial &&)>::value,
+                "Large trivial types should be passed by rvalue reference");
+  static_assert(
+      std::is_same<Invoker<void, CopyableMovableInstance>,
+                   void (*)(VoidPtr, CopyableMovableInstance &&)>::value,
+      "Types with copy/move ctor should be passed by rvalue reference");
+
+  // References are passed as references.
+  static_assert(
+      std::is_same<Invoker<void, int&>, void (*)(VoidPtr, int&)>::value,
+      "Reference types should be preserved");
+  static_assert(
+      std::is_same<Invoker<void, CopyableMovableInstance&>,
+                   void (*)(VoidPtr, CopyableMovableInstance&)>::value,
+      "Reference types should be preserved");
+  static_assert(
+      std::is_same<Invoker<void, CopyableMovableInstance&&>,
+                   void (*)(VoidPtr, CopyableMovableInstance &&)>::value,
+      "Reference types should be preserved");
+
+  // Make sure the address of an object received by reference is the same as the
+  // addess of the object passed by the caller.
+  {
+    LargeTrivial obj;
+    auto test = [&obj](LargeTrivial& input) { ASSERT_EQ(&input, &obj); };
+    absl::FunctionRef<void(LargeTrivial&)> ref(test);
+    ref(obj);
+  }
+
+  {
+    Trivial obj;
+    auto test = [&obj](Trivial& input) { ASSERT_EQ(&input, &obj); };
+    absl::FunctionRef<void(Trivial&)> ref(test);
+    ref(obj);
+  }
+}
+
+}  // namespace
+}  // inline namespace lts_2019_08_08
+}  // namespace absl
diff --git a/absl/functional/internal/front_binder.h b/absl/functional/internal/front_binder.h
new file mode 100644
index 0000000..acd6c71
--- /dev/null
+++ b/absl/functional/internal/front_binder.h
@@ -0,0 +1,95 @@
+// Copyright 2018 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Implementation details for `absl::bind_front()`.
+
+#ifndef ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
+#define ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
+
+#include <cstddef>
+#include <type_traits>
+#include <utility>
+
+#include "absl/base/internal/invoke.h"
+#include "absl/container/internal/compressed_tuple.h"
+#include "absl/meta/type_traits.h"
+#include "absl/utility/utility.h"
+
+namespace absl {
+inline namespace lts_2019_08_08 {
+namespace functional_internal {
+
+// Invoke the method, expanding the tuple of bound arguments.
+template <class R, class Tuple, size_t... Idx, class... Args>
+R Apply(Tuple&& bound, absl::index_sequence<Idx...>, Args&&... free) {
+  return base_internal::Invoke(
+      absl::forward<Tuple>(bound).template get<Idx>()...,
+      absl::forward<Args>(free)...);
+}
+
+template <class F, class... BoundArgs>
+class FrontBinder {
+  using BoundArgsT = absl::container_internal::CompressedTuple<F, BoundArgs...>;
+  using Idx = absl::make_index_sequence<sizeof...(BoundArgs) + 1>;
+
+  BoundArgsT bound_args_;
+
+ public:
+  template <class... Ts>
+  constexpr explicit FrontBinder(absl::in_place_t, Ts&&... ts)
+      : bound_args_(absl::forward<Ts>(ts)...) {}
+
+  template <class... FreeArgs,
+            class R = base_internal::InvokeT<F&, BoundArgs&..., FreeArgs&&...>>
+  R operator()(FreeArgs&&... free_args) & {
+    return functional_internal::Apply<R>(bound_args_, Idx(),
+                                         absl::forward<FreeArgs>(free_args)...);
+  }
+
+  template <class... FreeArgs,
+            class R = base_internal::InvokeT<const F&, const BoundArgs&...,
+                                             FreeArgs&&...>>
+  R operator()(FreeArgs&&... free_args) const& {
+    return functional_internal::Apply<R>(bound_args_, Idx(),
+                                         absl::forward<FreeArgs>(free_args)...);
+  }
+
+  template <class... FreeArgs, class R = base_internal::InvokeT<
+                                   F&&, BoundArgs&&..., FreeArgs&&...>>
+  R operator()(FreeArgs&&... free_args) && {
+    // This overload is called when *this is an rvalue. If some of the bound
+    // arguments are stored by value or rvalue reference, we move them.
+    return functional_internal::Apply<R>(absl::move(bound_args_), Idx(),
+                                         absl::forward<FreeArgs>(free_args)...);
+  }
+
+  template <class... FreeArgs,
+            class R = base_internal::InvokeT<const F&&, const BoundArgs&&...,
+                                             FreeArgs&&...>>
+  R operator()(FreeArgs&&... free_args) const&& {
+    // This overload is called when *this is an rvalue. If some of the bound
+    // arguments are stored by value or rvalue reference, we move them.
+    return functional_internal::Apply<R>(absl::move(bound_args_), Idx(),
+                                         absl::forward<FreeArgs>(free_args)...);
+  }
+};
+
+template <class F, class... BoundArgs>
+using bind_front_t = FrontBinder<decay_t<F>, absl::decay_t<BoundArgs>...>;
+
+}  // namespace functional_internal
+}  // inline namespace lts_2019_08_08
+}  // namespace absl
+
+#endif  // ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
diff --git a/absl/functional/internal/function_ref.h b/absl/functional/internal/function_ref.h
new file mode 100644
index 0000000..713edd6
--- /dev/null
+++ b/absl/functional/internal/function_ref.h
@@ -0,0 +1,106 @@
+// Copyright 2019 The Abseil Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
+#define ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
+
+#include <cassert>
+#include <functional>
+#include <type_traits>
+
+#include "absl/base/internal/invoke.h"
+#include "absl/meta/type_traits.h"
+
+namespace absl {
+inline namespace lts_2019_08_08 {
+namespace functional_internal {
+
+// Like a void* that can handle function pointers as well. The standard does not
+// allow function pointers to round-trip through void*, but void(*)() is fine.
+//
+// Note: It's important that this class remains trivial and is the same size as
+// a pointer, since this allows the compiler to perform tail-call optimizations
+// when the underlying function is a callable object with a matching signature.
+union VoidPtr {
+  const void* obj;
+  void (*fun)();
+};
+
+// Chooses the best type for passing T as an argument.
+// Attempt to be close to SystemV AMD64 ABI. Objects with trivial copy ctor are
+// passed by value.
+template <typename T>
+constexpr bool PassByValue() {
+  return !std::is_lvalue_reference<T>::value &&
+         absl::is_trivially_copy_constructible<T>::value &&
+         absl::is_trivially_copy_assignable<
+             typename std::remove_cv<T>::type>::value &&
+         std::is_trivially_destructible<T>::value &&
+         sizeof(T) <= 2 * sizeof(void*);
+}
+
+template <typename T>
+struct ForwardT : std::conditional<PassByValue<T>(), T, T&&> {};
+
+// An Invoker takes a pointer to the type-erased invokable object, followed by
+// the arguments that the invokable object expects.
+//
+// Note: The order of arguments here is an optimization, since member functions
+// have an implicit "this" pointer as their first argument, putting VoidPtr
+// first allows the compiler to perform tail-call optimization in many cases.
+template <typename R, typename... Args>
+using Invoker = R (*)(VoidPtr, typename ForwardT<Args>::type...);
+
+//
+// InvokeObject and InvokeFunction provide static "Invoke" functions that can be
+// used as Invokers for objects or functions respectively.
+//
+// static_cast<R> handles the case the return type is void.
+template <typename Obj, typename R, typename... Args>
+R InvokeObject(VoidPtr ptr, typename ForwardT<Args>::type... args) {
+  auto o = static_cast<const Obj*>(ptr.obj);
+  return static_cast<R>(
+      absl::base_internal::Invoke(*o, std::forward<Args>(args)...));
+}
+
+template <typename Fun, typename R, typename... Args>
+R InvokeFunction(VoidPtr ptr, typename ForwardT<Args>::type... args) {
+  auto f = reinterpret_cast<Fun>(ptr.fun);
+  return static_cast<R>(
+      absl::base_internal::Invoke(f, std::forward<Args>(args)...));
+}
+
+template <typename Sig>
+void AssertNonNull(const std::function<Sig>& f) {
+  assert(f != nullptr);
+  (void)f;
+}
+
+template <typename F>
+void AssertNonNull(const F&) {}
+
+template <typename F, typename C>
+void AssertNonNull(F C::*f) {
+  assert(f != nullptr);
+  (void)f;
+}
+
+template <bool C>
+using EnableIf = typename ::std::enable_if<C, int>::type;
+
+}  // namespace functional_internal
+}  // inline namespace lts_2019_08_08
+}  // namespace absl
+
+#endif  // ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
